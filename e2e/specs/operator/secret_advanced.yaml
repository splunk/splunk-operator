apiVersion: e2e.splunk.com/v1
kind: Test
metadata:
  name: operator_secret_s1_with_lm_mc_update
  description: "Secret update on standalone with License Manager and Monitoring Console"
  component: secret
  tags: [operator, secret, s1, license, monitoring_console, integration]
requires:
  - license
topology:
  kind: s1
steps:
  # Deploy License Manager
  - name: deploy_license_manager
    action: splunk.license_manager.deploy
  - name: wait_lm_ready
    action: k8s.wait.pod
    with:
      selector: app.kubernetes.io/component=license-manager
      condition: ready

  # Deploy Standalone with License Manager
  - name: deploy_standalone
    action: topology.deploy
    with:
      kind: s1
      license_manager_ref: ${license_manager_name}
  - name: wait_standalone_ready
    action: topology.wait_ready

  # Deploy Monitoring Console
  - name: deploy_monitoring_console
    action: splunk.monitoring_console.deploy
    with:
      name: ${standalone_name}
  - name: wait_mc_ready
    action: k8s.wait.pod
    with:
      selector: app.kubernetes.io/component=monitoring-console
      condition: ready

  # Capture initial resource version
  - name: capture_mc_version
    action: k8s.resource.get_version
    with:
      kind: monitoringconsole
      name: ${monitoring_console_name}

  # Update secrets
  - name: get_current_secret
    action: secret.get
    with:
      name: splunk-${namespace}-secret
  - name: update_secret_data
    action: secret.update
    with:
      name: splunk-${namespace}-secret
      data:
        hec_token: ${random_hec_token}
        password: ${random_password}
        pass4SymmKey: ${random_pass4symmkey}
        idxc_secret: ${random_idxc_secret}
        shc_secret: ${random_shc_secret}

  # Verify components update
  - name: verify_standalone_updating
    action: k8s.wait.phase
    with:
      kind: standalone
      name: ${standalone_name}
      phase: Updating
  - name: wait_lm_ready_after_update
    action: k8s.wait.pod
    with:
      selector: app.kubernetes.io/component=license-manager
      condition: ready
  - name: wait_standalone_ready_after_update
    action: topology.wait_ready
  - name: verify_mc_version_changed
    action: k8s.resource.verify_version_changed
    with:
      kind: monitoringconsole
      name: ${monitoring_console_name}
      previous_version: ${mc_resource_version}
  - name: wait_mc_ready_after_update
    action: k8s.wait.pod
    with:
      selector: app.kubernetes.io/component=monitoring-console
      condition: ready

  # Verify versioned secrets created
  - name: verify_versioned_secrets
    action: secret.verify.versioned
    with:
      namespace: ${namespace}
      version: 2
      expected_data:
        hec_token: ${random_hec_token}
        password: ${random_password}

  # Verify secrets mounted on pods
  - name: verify_secrets_on_pods
    action: secret.verify.mounted
    with:
      pods:
        - splunk-${license_manager_name}-license-manager-0
        - splunk-${standalone_name}-standalone-0
        - splunk-${monitoring_console_name}-monitoring-console-0
      expected_version: 2

  # Verify secrets in server.conf
  - name: verify_pass4symmkey_in_config
    action: splunk.config.verify
    with:
      pod: splunk-${standalone_name}-standalone-0
      config_file: /opt/splunk/etc/system/local/server.conf
      section: general
      key: pass4SymmKey
      value: ${random_pass4symmkey}

  # Verify API access with new password
  - name: verify_api_with_new_password
    action: splunk.api.verify_auth
    with:
      pod: splunk-${standalone_name}-standalone-0
      username: admin
      password: ${random_password}
---
apiVersion: e2e.splunk.com/v1
kind: Test
metadata:
  name: operator_secret_c3_cascade_update
  description: "Secret update cascades through cluster manager, indexers, and search heads"
  component: secret
  tags: [operator, secret, c3, integration]
topology:
  kind: c3
steps:
  - name: deploy
    action: topology.deploy
    with:
      kind: c3
      with_shc: true
      indexer_replicas: 3
      shc_replicas: 3
  - name: wait_ready
    action: topology.wait_ready
  - name: wait_stable
    action: topology.wait_stable

  # Capture initial bundle hash
  - name: capture_bundle_hash
    action: cluster.bundle.hash.capture

  # Update secret
  - name: update_secret
    action: secret.update
    with:
      name: splunk-${namespace}-secret
      data:
        password: ${random_password}
        idxc_secret: ${random_idxc_secret}
        shc_secret: ${random_shc_secret}

  # Verify cascade update
  - name: verify_cm_updating
    action: k8s.wait.phase
    with:
      kind: cluster_manager
      name: ${cluster_manager_name}
      phase: Updating
  - name: verify_indexers_updating
    action: k8s.wait.phase
    with:
      kind: indexercluster
      name: ${indexer_cluster_name}
      phase: Updating
  - name: verify_shc_updating
    action: k8s.wait.phase
    with:
      kind: searchheadcluster
      name: ${search_head_cluster_name}
      phase: Updating

  # Wait for all to be ready
  - name: wait_ready_after_update
    action: topology.wait_ready
  - name: wait_stable_after_update
    action: topology.wait_stable

  # Verify bundle push occurred
  - name: verify_bundle_push
    action: cluster.bundle.verify_push
    with:
      previous_hash: ${bundle_hash}
      replicas: 3

  # Verify secrets on all pods
  - name: verify_cm_secret
    action: secret.verify.mounted
    with:
      pods:
        - splunk-${cluster_manager_name}-cluster-manager-0
      expected_version: 2
  - name: verify_indexer_secrets
    action: secret.verify.mounted
    with:
      pods:
        - splunk-${indexer_cluster_name}-indexer-0
        - splunk-${indexer_cluster_name}-indexer-1
        - splunk-${indexer_cluster_name}-indexer-2
      expected_version: 2
  - name: verify_shc_secrets
    action: secret.verify.mounted
    with:
      pods:
        - splunk-${search_head_cluster_name}-search-head-0
        - splunk-${search_head_cluster_name}-search-head-1
        - splunk-${search_head_cluster_name}-search-head-2
      expected_version: 2

  # Verify cluster still functions
  - name: verify_rf_sf
    action: assert.cluster.rf_sf
  - name: verify_search_works
    action: splunk.search.sync
    with:
      query: "| makeresults | eval test='secret_update_test'"
      pod: splunk-${search_head_cluster_name}-search-head-0
---
apiVersion: e2e.splunk.com/v1
kind: Test
metadata:
  name: operator_secret_m4_multisite_update
  description: "Secret update in multisite cluster with different site configurations"
  component: secret
  tags: [operator, secret, m4, multisite, integration]
topology:
  kind: m4
  params:
    site_count: "3"
steps:
  - name: deploy
    action: topology.deploy
    with:
      kind: m4
      site_count: 3
      indexer_replicas: 1
      shc_replicas: 3
  - name: wait_ready
    action: topology.wait_ready
  - name: verify_multisite
    action: assert.cluster.multisite_sites
    with:
      site_count: 3

  # Update secrets
  - name: update_secret
    action: secret.update
    with:
      name: splunk-${namespace}-secret
      data:
        password: ${random_password}
        idxc_secret: ${random_idxc_secret}
        shc_secret: ${random_shc_secret}

  # Wait for update across all sites
  - name: wait_ready_after_update
    action: topology.wait_ready
  - name: wait_stable_after_update
    action: topology.wait_stable

  # Verify multisite configuration persists
  - name: verify_multisite_after_update
    action: assert.cluster.multisite_sites
    with:
      site_count: 3
  - name: verify_rf_sf
    action: assert.cluster.rf_sf

  # Verify secrets on all sites
  - name: verify_site1_secret
    action: secret.verify.mounted
    with:
      pods:
        - splunk-${base_name}-site1-indexer-0
      expected_version: 2
  - name: verify_site2_secret
    action: secret.verify.mounted
    with:
      pods:
        - splunk-${base_name}-site2-indexer-0
      expected_version: 2
  - name: verify_site3_secret
    action: secret.verify.mounted
    with:
      pods:
        - splunk-${base_name}-site3-indexer-0
      expected_version: 2
---
apiVersion: e2e.splunk.com/v1
kind: Test
metadata:
  name: operator_secret_rotation_stress_test
  description: "Stress test with multiple rapid secret rotations"
  component: secret
  tags: [operator, secret, s1, stress, resilience]
topology:
  kind: s1
steps:
  - name: deploy
    action: topology.deploy
  - name: wait_ready
    action: topology.wait_ready

  # Perform multiple rapid secret updates
  - name: update_secret_1
    action: secret.update
    with:
      name: splunk-${namespace}-secret
      data:
        password: ${random_password_1}
  - name: wait_updating_1
    action: k8s.wait.phase
    with:
      kind: standalone
      name: ${standalone_name}
      phase: Updating
  - name: wait_ready_1
    action: topology.wait_ready

  - name: update_secret_2
    action: secret.update
    with:
      name: splunk-${namespace}-secret
      data:
        password: ${random_password_2}
  - name: wait_updating_2
    action: k8s.wait.phase
    with:
      kind: standalone
      name: ${standalone_name}
      phase: Updating
  - name: wait_ready_2
    action: topology.wait_ready

  - name: update_secret_3
    action: secret.update
    with:
      name: splunk-${namespace}-secret
      data:
        password: ${random_password_3}
  - name: wait_updating_3
    action: k8s.wait.phase
    with:
      kind: standalone
      name: ${standalone_name}
      phase: Updating
  - name: wait_ready_3
    action: topology.wait_ready

  # Verify final state
  - name: verify_final_secret_version
    action: secret.verify.versioned
    with:
      namespace: ${namespace}
      version: 4  # Initial + 3 updates
      expected_data:
        password: ${random_password_3}

  - name: verify_api_with_latest_password
    action: splunk.api.verify_auth
    with:
      pod: splunk-${standalone_name}-standalone-0
      username: admin
      password: ${random_password_3}

  - name: verify_no_pod_restarts
    action: assert.pod.restart_count
    with:
      pod: splunk-${standalone_name}-standalone-0
      max_restarts: 0
