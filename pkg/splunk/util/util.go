// Copyright (c) 2018-2022 Splunk Inc. All rights reserved.

//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package util

import (
	"bytes"
	"context"
	"net/http"
	"os"
	"strings"

	enterpriseApi "github.com/splunk/splunk-operator/api/v4"

	splcommon "github.com/splunk/splunk-operator/pkg/splunk/common"
	corev1 "k8s.io/api/core/v1"
	errors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/serializer"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/tools/remotecommand"
	"k8s.io/kubectl/pkg/scheme"
	"sigs.k8s.io/controller-runtime/pkg/client/apiutil"
	"sigs.k8s.io/controller-runtime/pkg/client/config"

	"sigs.k8s.io/controller-runtime/pkg/log"
)

// kubernetes logger used by splunk.reconcile package
//var log = logf.Log.WithName("splunk.reconcile")

// TestResource defines a simple custom resource, used to test the Spec
type TestResource struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              enterpriseApi.Spec `json:"spec,omitempty"`
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (cr *TestResource) DeepCopyInto(out *TestResource) {
	*out = *cr
	out.TypeMeta = cr.TypeMeta
	cr.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	cr.Spec.DeepCopyInto(&out.Spec)
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TestResource.
func (cr *TestResource) DeepCopy() *TestResource {
	if cr == nil {
		return nil
	}
	out := new(TestResource)
	cr.DeepCopyInto(out)
	return out
}

// DeepCopyObject copies the receiver, creating a new runtime.Object.
func (cr *TestResource) DeepCopyObject() runtime.Object {
	if c := cr.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// CreateResource creates a new Kubernetes resource using the REST API.
func CreateResource(ctx context.Context, client splcommon.ControllerClient, obj splcommon.MetaObject) error {
	reqLogger := log.FromContext(ctx)
	scopedLog := reqLogger.WithName("CreateResource").WithValues(
		"name", obj.GetObjectMeta().GetName(),
		"namespace", obj.GetObjectMeta().GetNamespace())

	err := client.Create(ctx, obj)

	if err != nil && !errors.IsAlreadyExists(err) {
		scopedLog.Error(err, "Failed to create resource", "kind", obj.GetObjectKind())
		return err
	}

	scopedLog.Info("Created resource", "kind", obj.GetObjectKind())

	return nil
}

// UpdateResource updates an existing Kubernetes resource using the REST API.
func UpdateResource(ctx context.Context, client splcommon.ControllerClient, obj splcommon.MetaObject) error {
	reqLogger := log.FromContext(ctx)
	scopedLog := reqLogger.WithName("UpdateResource").WithValues(
		"name", obj.GetObjectMeta().GetName(),
		"namespace", obj.GetObjectMeta().GetNamespace())
	err := client.Update(ctx, obj)

	if err != nil && !errors.IsAlreadyExists(err) {
		scopedLog.Error(err, "Failed to update resource", "kind", obj.GetObjectKind())
		return err
	}
	scopedLog.Info("Updated resource", "kind", obj.GetObjectKind())

	return nil
}

// DeleteResource deletes an existing Kubernetes resource using the REST API.
func DeleteResource(ctx context.Context, client splcommon.ControllerClient, obj splcommon.MetaObject) error {
	reqLogger := log.FromContext(ctx)
	scopedLog := reqLogger.WithName("DeleteResource").WithValues(
		"name", obj.GetObjectMeta().GetName(),
		"namespace", obj.GetObjectMeta().GetNamespace())
	err := client.Delete(ctx, obj)

	if err != nil && !errors.IsAlreadyExists(err) {
		scopedLog.Error(err, "Failed to delete resource", "kind", obj.GetObjectKind())
		return err
	}

	scopedLog.Info("Deleted resource", "kind", obj.GetObjectKind())

	return nil
}

// generateHECToken returns a randomly generated HEC token formatted like a UUID.
// Note that it is not strictly a UUID, but rather just looks like one.
func generateHECToken() []byte {
	hecToken := splcommon.GenerateSecret(splcommon.HexBytes, 36)
	hecToken[8] = '-'
	hecToken[13] = '-'
	hecToken[18] = '-'
	hecToken[23] = '-'
	return hecToken
}

// PodExecCommand execute a shell command in the specified pod
func PodExecCommand(ctx context.Context, c splcommon.ControllerClient, podName string, namespace string, cmd []string, streamOptions *remotecommand.StreamOptions, tty bool, mock bool) (string, string, error) {
	var pod corev1.Pod

	// Get Pod
	namespacedName := types.NamespacedName{Namespace: namespace, Name: podName}
	err := c.Get(ctx, namespacedName, &pod)
	if err != nil {
		return "", "", err
	}

	gvk, _ := apiutil.GVKForObject(&pod, scheme.Scheme)
	var restConfig *rest.Config
	if !mock {
		restConfig, err = config.GetConfig()
		if err != nil {
			return "", "", err
		}
	} else {
		path := os.Getenv("PWD") + "/kubeconfig"
		restConfig, err = clientcmd.BuildConfigFromFlags("", path)
		if err != nil {
			return "", "", err
		}
	}
	restClient, err := apiutil.RESTClientForGVK(gvk, false, restConfig, serializer.NewCodecFactory(scheme.Scheme))
	if err != nil {
		return "", "", err
	}
	execReq := restClient.Post().Resource("pods").Name(podName).Namespace(namespace).SubResource("exec")
	option := &corev1.PodExecOptions{
		Command: cmd,
		Stdin:   true,
		Stdout:  true,
		Stderr:  true,
		TTY:     tty,
	}
	if streamOptions == nil {
		option.Stdin = false
	}
	execReq.VersionedParams(
		option,
		scheme.ParameterCodec,
	)
	exec, err := remotecommand.NewSPDYExecutor(restConfig, http.MethodPost, execReq.URL())
	if err != nil {
		return "", "", err
	}
	stdout := new(bytes.Buffer)
	stderr := new(bytes.Buffer)

	streamOptions.Stdout = stdout
	streamOptions.Stderr = stderr

	err = exec.Stream(*streamOptions)

	return stdout.String(), stderr.String(), err
}

// PodExecClientImpl is an interface which is used to implement
// PodExecClient to run pod exec commands
// NOTE: This client will be helpful in UTs since we can create
// our own mock client and pass it to the tests to work correctly.
type PodExecClientImpl interface {
	RunPodExecCommand(context.Context, *remotecommand.StreamOptions, []string) (string, string, error)
	SetTargetPodName(context.Context, string)
	GetTargetPodName() string
	GetCR() splcommon.MetaObject
	SetCR(splcommon.MetaObject)
}

// blank assignment to implement PodExecClientImpl
var _ PodExecClientImpl = &PodExecClient{}

// PodExecClient implements PodExecClientImpl
type PodExecClient struct {
	client        splcommon.ControllerClient
	cr            splcommon.MetaObject
	targetPodName string
}

// GetPodExecClient returns the client object used to execute pod exec commands
func GetPodExecClient(client splcommon.ControllerClient, cr splcommon.MetaObject, targetPodName string) *PodExecClient {
	return &PodExecClient{
		client:        client,
		cr:            cr,
		targetPodName: targetPodName,
	}
}

// suppressHarmlessErrorMessages suppresses harmless error messages
func suppressHarmlessErrorMessages(values ...*string) {
	for _, val := range values {
		// Replace ssh warning message
		if strings.Contains(*val, splunkSSHWarningMessage) {
			*val = strings.ReplaceAll(*val, splunkSSHWarningMessage, "")
		}

		// Replace es app ssl warning
		if strings.Contains(*val, splunkEsAppSSLWarning) {
			*val = strings.ReplaceAll(*val, splunkEsAppSSLWarning, "")
		}
	}
}

// RunPodExecCommand runs the specific pod exec command
func (podExecClient *PodExecClient) RunPodExecCommand(ctx context.Context, streamOptions *remotecommand.StreamOptions, baseCmd []string) (string, string, error) {
	reqLogger := log.FromContext(ctx)
	errmsg := ""
	stdOut, stdErr, err := PodExecCommand(ctx, podExecClient.client, podExecClient.targetPodName, podExecClient.cr.GetNamespace(), baseCmd, streamOptions, false, false)
	if err != nil {
		errmsg = err.Error()
	}
	reqLogger.Info("podexec call returned", "cmd", strings.Join(baseCmd, " "), "stdout", stdOut, "stderr", stdErr, "err", errmsg)

	// Note: splunk 9.0 throws a few harmless warning error messages, suppress it!
	suppressHarmlessErrorMessages(&stdErr, &stdOut)

	return stdOut, stdErr, err
}

// SetTargetPodName sets the targetPodName field for podExecClient
func (podExecClient *PodExecClient) SetTargetPodName(ctx context.Context, targetPodName string) {
	podExecClient.targetPodName = targetPodName
}

// GetTargetPodName returns the target pod name
func (podExecClient *PodExecClient) GetTargetPodName() string {
	return podExecClient.targetPodName
}

// GetCR returns the CR from the PodExecClient
func (podExecClient *PodExecClient) GetCR() splcommon.MetaObject {
	return podExecClient.cr
}

// SetCR sets the PodExecClient CR
func (podExecClient *PodExecClient) SetCR(cr splcommon.MetaObject) {
	podExecClient.cr = cr
}

// NewStreamOptionsObject return a new streamoptions object for the given command
func NewStreamOptionsObject(command string) *remotecommand.StreamOptions {
	return &remotecommand.StreamOptions{
		Stdin: strings.NewReader(command),
	}
}

// ResetStringReader resets the Stdin (of strings.Reader type) of the remotecommand.StreamOptions
func ResetStringReader(streamOptions *remotecommand.StreamOptions, command string) {
	// convert Stdin of type io.Reader to strings.Reader type
	stdInReader, ok := streamOptions.Stdin.(*strings.Reader)
	if !ok {
		return
	}
	// reset the offset of the Reader
	stdInReader.Reset(command)
}
